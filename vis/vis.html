<script src="../node_modules/d3/d3.js?dontprocess=yes"></script>
<script src="../backbone-todomvc/modules/underscore/underscore.js?dontprocess=yes"></script>
<meta charset="utf-8" />

<div id="info" style="position: absolute; width: 100%; left: 0; top: 0; background: white"></div>


<style>
body {
    margin: 0;
    font-family: Arial;
}
blockquote {
    padding-left: 10px;
    margin: 0
}

.value-blockquote a:hover {
    color: lime;
}

.selected {
    stroke: green;
}

.stack-frame--highlight {
    font-weight: bold
}

.stack-frame--library {
    opacity: .5;
}

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

.stack-frame {
    overflow: hidden;
    font-family: monospace;
}
.stack-frame__file-and-function {
    float: left;
    width: 40%;
}
.stack-frame__source {
    float: left;
    width: 60%;
}

</style>

<div id="viz"></div>
<script>

function nodeIsHTMLElement(node){
    return node.action === "initial html" || node.action === "content from initial html" ||
        node.action === "createElement" || node.action === "assign innerHTML" ||
        node.action === "appendChild"
}

function nodeIsValueSource(node){
    return node.action === "string literal" || node.action === "localStorage.getItem"
}

function showInfo(info){
    document.getElementById("info").innerHTML = ""

    var html = "<u>" + info.action + " </u><br/>"
    var header = document.createElement("div")
    header.innerHTML = html;
    document.getElementById("info").appendChild(header)
    html = ""

    var value = info.value;
    if (value === undefined) {
        value = "(no value available)"
    }
    if (value === "") {
        value = "(empty string)"
    }

    var valueBlockQuote = document.createElement("blockquote")
    valueBlockQuote.classList.add("value-blockquote")
    for (let index in value){
        var char = value[index]
        var a = document.createElement("a")
        a.innerHTML = escapeAngleBrackets(char)
        a.onclick = function(){
            nodes = []
            links = []
            processOriginObject(info)

            var charOrigin = whereDoesCharComeFrom(info, index)
            charOrigin.forEach(function(o){
                if (!o.originObject)return
                o.originObject.isInCurrentPath = true;
            })

            document.querySelector("svg").remove()
            onload()
        }
        valueBlockQuote.appendChild(a)
    }
    document.getElementById("info").appendChild(valueBlockQuote)


    var hasHighlighted = false
    if (info.resolvedStack) {
        info.resolvedStack.forEach(function(frame){
            var fileNameParts = frame.fileName.split("/")
            var fileName = fileNameParts[fileNameParts.length - 1]

            var isLibrary = fileName.indexOf("underscore") !== -1 || fileName.indexOf("jquery") !== -1

            var isLibraryClass = isLibrary ? "stack-frame--library" : ""

            var highlightClass = "";
            if (!hasHighlighted) {
                if (!isLibrary){
                    highlightClass = "stack-frame--highlight"
                    hasHighlighted = true
                }

            }

            var line = "";

            if (frame.line){
                line = escapeAngleBrackets(frame.line.substr(0, frame.columnNumber)) +
                    "<span style='color: red; '>|</span>" +
                    escapeAngleBrackets(frame.line.substr(frame.columnNumber));
            }


            html += `<div class="stack-frame ${highlightClass} ${isLibraryClass}">
                <div class="stack-frame__file-and-function">
                    ${fileName}:${frame.lineNumber} / ${frame.functionName}
                </div>
                <div class="stack-frame__source ">
                    ${line}
                </div>
            </div>`;
        })
    }
    var stacktrace = document.createElement("div")
    stacktrace.innerHTML = html;
    document.getElementById("info").appendChild(stacktrace)
}

function escapeAngleBrackets(str){
    return str.replace(/\</g, "&lt;").replace(/\>/g, "&gt;")
}

function ValueMap(){
    this.charIndex = 0;
    this.items = [];
}
ValueMap.prototype.append = function(originObject){
    this.appendString(originObject.value, originObject)
}
ValueMap.prototype.appendString = function(str, originObject){
    var newCharIndex = this.charIndex + str.length;
    this.items.push({
        originObject: originObject,
        fromCharIndex: this.charIndex,
        toCharIndex: newCharIndex,
        __justForDebuggingStr: str
    })
    this.charIndex = newCharIndex
}
ValueMap.prototype.getItemAt = function(charIndex){
    var matchingItems = this.items.filter(function(o){
        return o.fromCharIndex <= charIndex && o.toCharIndex >= charIndex
    })
    var matchingItem
    if (matchingItems.length > 1 && matchingItems[0].originObject.value === "") {
        // "" can't ever meaningfully be the source of a visible string
        matchingItem = matchingItems[1]
    }
    else {
        matchingItem = matchingItems[0]
    }

    var itemsBeforeMatch = this.items.slice(0, this.items.indexOf(matchingItem));
    var charCountBeforeMatch = 0;
    itemsBeforeMatch.forEach(function(item){
        charCountBeforeMatch += item.toCharIndex - item.fromCharIndex
    })

    var originObject = matchingItem.originObject
    var characterIndex = charIndex - charCountBeforeMatch

    if (originObject.value.length < characterIndex) {
        console.error("it looks like the string originated outside the actual origin value")
        debugger;
    }

    return {
        originObject: originObject,
        characterIndex: characterIndex
    }
}

var nodes= [];
var links = [];

function whereDoesCharComeFrom(originObject, characterIndex){
    var steps = [];
    var step = {
        originObject: originObject,
        characterIndex: characterIndex
    }
    steps.push(step)
    while (step.originObject){
        step = goUp(step)
        steps.push(step)
    }
    return steps
}
function goUp(step){
    // just pushes the value further up, without changing anything (prob means this action didn't modify the value)
    var forwardingObject ={
        originObject: step.originObject.inputValues[0],
        characterIndex: step.characterIndex
    }

    if (step.originObject.inputValues.length === 1 && step.originObject.inputValues[0].value === step.originObject.value) {
        return forwardingObject
    }
    if (step.originObject.action === "concat") {
        var valueMap = new ValueMap()
        valueMap.append(step.originObject.inputValues[0])
        valueMap.append(step.originObject.inputValues[1])

        return valueMap.getItemAt(step.characterIndex)
    }
    if (step.originObject.action === "Element") {
        var valueMap = new ValueMap();
        var createElement;
        if (step.originObject.inputValues[0].action === "createElement") {
            createElement = step.originObject.inputValues[0];
        }
        if (createElement) {
            valueMap.appendString("<" + createElement.inputValues[0].value + ">", createElement)
        }
        step.originObject.inputValues.forEach(function(inputValue){
            if (inputValue.action === "createElement") {
                return;
            }
            if (inputValue.action === "appendChild"){
                valueMap.append(inputValue)
            }
            if (inputValue.action === "assign innerHTML"){
                valueMap.append(inputValue)
            }
            throw "unhandled input value in elment item"

        })
        if (createElement) {
            valueMap.appendString("</" + createElement.inputValues[0].value + ">", createElement)
        }

        return valueMap.getItemAt(step.characterIndex)
    }
    if (step.originObject.action === "createElement") {
        return forwardingObject
    }
    console.log("not handling step", step)
    return {}
}



// processOriginObject(window.visOriginData)
processOriginObject(JSON.parse(localStorage.getItem("visData")))
function processOriginObject(origin){
    var index = nodes.length;
    origin.index = index;

    origin.isInCurrentPath = false
    nodes.push(origin)

    if (origin.inputValues) {
        origin.inputValues.forEach(function(inputValue){
            if (inputValue===null){return}
            var inputIndex = processOriginObject(inputValue)
            links.push({
                source: index,
                target: inputIndex,
                value: 20
            })
        })
    }
    if (origin.children){
        origin.children.forEach(function(child){
            var childIndex = processOriginObject(child)
            links.push({
                source: index,
                target: childIndex,
                value: 20
            })
        })
    }

    return index;
}



window.onload = function onload(){

    var force = d3.layout.force()
        .charge(-200)
        .linkDistance(40)

    var svg = d3.select("body").append("svg")


    function updateSize(){
        force.size([document.body.clientWidth, document.body.clientHeight])
        svg
            .attr("width", document.body.clientWidth)
            .attr("height", document.body.clientHeight);
    }

    updateSize()

    var graph = {
        nodes: nodes,
        links: links
    }

      force
          .nodes(graph.nodes)
          .links(graph.links)
          .start();

      var link = svg.selectAll(".link")
          .data(graph.links)
        .enter().append("line")
          .attr("class", "link")
          .style("stroke-width", function(d) { return Math.sqrt(d.value); });

      var node = svg.selectAll(".node")
          .data(graph.nodes)
        .enter()
        .append("g")

        node.append("circle")
          .attr("class", "node")
          .attr("r", 5)
          .call(force.drag)

          node.append("text")
            .style("font-size", 12)
            .text(function(d) {
                var text = d.action + (d.actionDetails ? " " + d.actionDetails : "");
                if (d.action === "string literal"){
                    var truncatedValue = d.value
                    if (truncatedValue.length > 25) {
                        truncatedValue = truncatedValue.substr(0, 25) + "..."
                    }
                    text = '"' + truncatedValue + '"'
                }
                text = text.replace(/\n/g, "\\n")
                return text;
            })
            .on("mouseenter", function(d){
                var currentSelection = document.querySelector(".selected")
                window.lastHover = d
                if (currentSelection) {
                    currentSelection.classList.remove("selected")
                }

                this.classList.add("selected")

                showInfo(d);
                console.log(d)
            })
            .on("click", function(d){
                nodes = []
                links = []
                processOriginObject(d)
                document.querySelector("svg").remove()
                onload()

            })


      force.on("tick", function() {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });


        node.selectAll("circle")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("fill", function(d){
                if (d.isInCurrentPath) {
                    return "lime"
                }
                if (d.index === 0) {
                    return "red"
                }
                if (nodeIsHTMLElement(d)){
                    return "blue"
                }
                if (nodeIsValueSource(d)){
                    return "orange"
                }
                return "black"
            })


        node.selectAll("text")
            .attr("transform", function(d){
                var x = d.x;
                var y=  d.y;
                return "translate(" + x + "," + y + ")"
            })
      });

      window.onresize = throttle(function(){
          updateSize();
          force.start();
      }, 500);
  }


</script>
<script>

function throttle(fn, opts) {
  opts = opts || {}
  var timer
  var queue = []
  const errMsg = 'Must pass options or milliseconds as second argument'
  if (!opts)
    throw new Error(errMsg)

  var msBetweenCalls

  if (typeof opts == 'string')
    msBetweenCalls = Number(opts)

  else if (typeof opts == 'number')
    msBetweenCalls = opts

  else {
    const window = opts.window || 1
    const limit = opts.limit || 1
    const exact = opts.exact || false
    msBetweenCalls = Math.ceil((window / limit) * 1000)
  }

  if (isNaN(msBetweenCalls))
    throw new Error(errMsg)

  function enqueue(args) {
    return queue.push(args)
  }

  function dequeue() {
    return queue.shift()
  }

  function kickQueue() {
    if (timer) return timer
    timer = setInterval(runQueue, msBetweenCalls)
    return timer
  }

  function runQueue() {
    const args = dequeue()

    if (queue.length == 0 || !args) {
      clearInterval(timer)
      timer = null
    }

    const result = fn.apply(null, args)
    return result
  }

  const throttled = function () {
    const args = [].slice.call(arguments)
    const position = enqueue(args)
    const timer = kickQueue()

    return {
      position: position,
      queuedAt: Date.now(),
      timeUntilCall: position * msBetweenCalls
    }
  }

  return throttled
}</script>
